package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/somatom98/badges/domain"
	"github.com/somatom98/badges/graph/model"
)

// Type is the resolver for the type field.
func (r *eventResolver) Type(ctx context.Context, obj *domain.Event) (string, error) {
	return string(obj.Type), nil
}

// Date is the resolver for the date field.
func (r *eventResolver) Date(ctx context.Context, obj *domain.Event) (string, error) {
	return obj.Date.String(), nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.NewEvent) (*domain.Event, error) {
	event := domain.Event{
		ID:   uuid.New().String(),
		UID:  input.User,
		Type: input.Type,
		Date: time.Now().UTC(),
	}

	err := r.EventService.AddUserEvent(ctx, event)
	return &event, err
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, id string) ([]*domain.Event, error) {
	events, err := r.EventService.GetEventsByUserID(ctx, id)
	if err != nil {
		return nil, err
	}

	nEvents := []*domain.Event{}
	for i, _ := range events {
		nEvents = append(nEvents, &events[i])
	}

	return nEvents, nil
}

// ReportsEvents is the resolver for the reportsEvents field.
func (r *queryResolver) ReportsEvents(ctx context.Context, mid string) ([]*domain.Event, error) {
	events, err := r.EventService.GetEventsByManagerID(ctx, mid)
	if err != nil {
		return nil, err
	}

	nEvents := []*domain.Event{}
	for i, _ := range events {
		nEvents = append(nEvents, &events[i])
	}

	return nEvents, nil
}

// Events is the resolver for the events field.
func (r *subscriptionResolver) Events(ctx context.Context, id *string) (<-chan *domain.Event, error) {
	return r.EventConsumer.Consume(ctx, nil)
}

// Type is the resolver for the type field.
func (r *newEventResolver) Type(ctx context.Context, obj *model.NewEvent, data string) error {
	switch data {
	case string(domain.EventTypeIn):
		obj.Type = domain.EventTypeIn
	case string(domain.EventTypeOut):
		obj.Type = domain.EventTypeOut
	default:
		return fmt.Errorf("err_invalid_value")
	}

	return nil
}

// Event returns EventResolver implementation.
func (r *Resolver) Event() EventResolver { return &eventResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

// NewEvent returns NewEventResolver implementation.
func (r *Resolver) NewEvent() NewEventResolver { return &newEventResolver{r} }

type eventResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type newEventResolver struct{ *Resolver }
